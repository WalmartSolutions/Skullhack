package com.canon.majik.impl.modules.impl.exploit;

import com.canon.majik.api.event.eventBus.EventListener;
import com.canon.majik.api.event.events.PacketEvent;
import com.canon.majik.api.event.events.Render3DEvent;
import com.canon.majik.api.event.events.TickEvent;
import com.canon.majik.api.utils.client.TColor;
import com.canon.majik.api.utils.client.Timer;
import com.canon.majik.api.utils.player.BlockUtil;
import com.canon.majik.api.utils.render.RenderUtils;
import com.canon.majik.impl.modules.api.Category;
import com.canon.majik.impl.modules.api.Module;
import com.canon.majik.impl.setting.settings.BooleanSetting;
import com.canon.majik.impl.setting.settings.ColorSetting;
import com.canon.majik.impl.setting.settings.NumberSetting;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityEnderCrystal;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.*;
import net.minecraft.util.math.Vec3d;

import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class FakeLatency  extends Module {
    private final NumberSetting delay = setting("Delay", 100, 50, 1000);
    private final BooleanSetting sendOnSafe = setting("Send on safe", true);
    private final BooleanSetting sendSmart = setting("Send smart", true);
    private final BooleanSetting sendOnDamage = setting("Send on damage", true);
    private final ColorSetting render = setting("Render", new TColor(132, 180, 0));
    private final Timer queueTimer = new Timer(), holeTimer = new Timer();
    private final Queue<Packet<?>> queue = new ConcurrentLinkedQueue<>();
    private Vec3d vec;
    private boolean prevGround;

    public FakeLatency(String name,Category category) {
        super(name, category);
    }

    @EventListener
    public void onTick(TickEvent event) {
        if (sendSmart.getValue()) {
            if (prevGround && !mc.player.onGround && holeTimer.over(delay.getValue().floatValue())) {
                sendQueue();
            }
            prevGround = mc.player.onGround;
        }
        if (queueTimer.over(delay.getValue().floatValue()) || mc.player.fallDistance > 10) {
            sendQueue();
        }

        if (sendOnDamage.getValue() && holeTimer.over(delay.getValue().floatValue())) {
            float damage = getPredictedDamage(mc.player.getPositionVector());
            float sentDamage = getPredictedDamage(vec);
            if (damage < sentDamage) {
                sendQueue();
            }
        }
    }

    @EventListener
    public void onPacketSend(PacketEvent.Send event) {
        if (mc.player == null || mc.world == null || mc.isSingleplayer()) {
            return;
        }
        if (sendOnSafe.getValue() && BlockUtil.isPlayerSafe(mc.player)) {
            sendQueue();
            holeTimer.sync();
            return;
        }
        if (sendSmart.getValue()) {
            if (event.getPacket() instanceof CPacketUseEntity
                    || event.getPacket() instanceof CPacketClickWindow
                    || event.getPacket() instanceof CPacketCloseWindow
                    || event.getPacket() instanceof CPacketConfirmTeleport
                    || event.getPacket() instanceof CPacketHeldItemChange
                    || event.getPacket() instanceof CPacketPlayerTryUseItem
                    || event.getPacket() instanceof CPacketPlayerTryUseItemOnBlock
                    || event.getPacket() instanceof CPacketPlayerDigging) {
                sendQueue();
                return;
            }
        }

        queue.add(event.getPacket());
        event.setCancelled(true);
    }

    //Todo
    @EventListener
    public void onRender3D(Render3DEvent event) {
        if (nullCheck()) {
            if (vec == null) {
                return;
            }
        }
    }

    private float getPredictedDamage(Vec3d vec) {
        float totalDamage = 0.0f;
        Vec3d pos = mc.player.getPositionVector();
        mc.player.setPosition(vec.x, vec.y, vec.z);
        for (Entity entity : mc.world.loadedEntityList) {
            if (!(entity instanceof EntityEnderCrystal) || BlockUtil.distance(entity.getPosition()) > 5) {
                continue;
            }
            totalDamage += BlockUtil.calculateEntityDamage((EntityEnderCrystal) entity, mc.player);
        }
        mc.player.setPosition(pos.x, pos.y, pos.z);
        return totalDamage;
    }

    private void sendQueue() {
        while (!queue.isEmpty()) {
            if (mc.getConnection() != null) {
                mc.getConnection().getNetworkManager().channel().writeAndFlush(queue.poll());
            }
        }
        vec = mc.player.getPositionEyes(mc.getRenderPartialTicks()).add(0, -mc.player.eyeHeight, 0);
        queueTimer.sync();
    }
}